# 微信小程序



## 目录

- [HTML](../html/html.md)

- [CSS](../css/css.md)

- [JavaScript](../js/js.md)

- [笔试题](../code/code.md)

- [TypeScript](../typescript/typescript.md)

- [Vue](../vue/vue.md)

- [Webpack 和前端工程化](../webpack/webpack.md)

- [微信小程序](../mini-program/mini-program.md)



## 小程序、H5 和 APP



## 小程序架构

小程序的运行环境氛围**渲染层**和**逻辑层**。其中**渲染层**使用 WebView 进行渲染，**逻辑层**采用 JSCore 线程运行脚本文件，这两个线程的通信通过小程序客户端（Native）进行中转，逻辑层的网络请求也通过 Native 进行转发。

![framework](./assets/framework.png)



## 目录结构

小程序包含一个描述整体程序的 `app` 和多个描述各自页面的 `page`。

一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：

| 文件     | 必需 | 作用                                              |
| -------- | ---- | ------------------------------------------------- |
| app.js   | 是   | 小程序逻辑                                        |
| app.json | 是   | 小程序公共配置（页面配置、界面表现、底部 tab 等） |
| app.wxss | 否   | 小程序公共样式                                    |

一个小程序页面由四个文件组成，分别是：

| 文件类型            | 必需 | 作用       |
| ------------------- | ---- | ---------- |
| js                  | 是   | 页面逻辑   |
| wxml（相当于 HTML） | 是   | 页面结构   |
| json                | 否   | 页面配置   |
| wxss（相当于 CSS）  | 否   | 页面样式表 |



## 响应的数据绑定

出于安全考虑，小程序不允许像 H5 那样通过 DOM 来获取元素以及修改数据，而是采用了类似 Vue 的数据绑定和模板语法。因为小程序的渲染线程和脚本线程互斥，所以修改数据需要通过 `this.setData()` 方法通知渲染线程更新数据。

```html
<view> Hello {{name}}! </view>
<button bindtap="changeName"> Click me! </button>
```

```js
Page({
  data: {
    name: 'Weixin'
  },
  changeName() {
    this.setData({
      name: 'MINA'
    })
  }
})
```



## 页面栈和路由

小程序以栈的形式维护了当前的所有页面。 

| 路由方式   | 页面栈表现                        | 触发时机                                                     | 路由前页面 | 路由后页面     |
| ---------- | --------------------------------- | ------------------------------------------------------------ | ---------- | -------------- |
| 初始化     | 新页面入栈                        | 小程序打开的第一个页面                                       |            | onLoad，onShow |
| 打开新页面 | 新页面入栈                        | 调用 API：`wx.navigateTo`<br/>使用组件：`<navigator open-type="navigateTo">` | onHide     | onLoad，onShow |
| 页面重定向 | 当前页面出栈，新页面入栈          | 调用 API：`wx.redirectTo`<br/>使用组件：`<navigator open-type="redirectTo">` | onUnload   | onLoad，onShow |
| 页面返回   | 页面不断出栈，直到目标返回页      | 调用 API：`wx.navigateBack`<br/>使用组件：`<navigator open-type="navigateBack">`<br/>用户按返回按钮 | onUnload   | onShow         |
| Tab 切换   | 页面全部出栈，只留下新的 Tab 页面 | 调用 API：`wx.switchTab`<br/>使用组件：`<navigator open-type="switchTab">`<br/>用户切换 Tab | 略         | 略             |
| 重启动     | 页面全部出栈，只留下新的页面      | 调用 API：`wx.reLaunch`<br/>使用组件：`<navigator open-type="reLaunch">` | onUnload   | onLoad，onShow |



## 尺寸单位 rpx

为了方便页面根据宽度适配，小程序引入一个新的尺寸单位 rpx，并规定屏幕宽度为 750 rpx，这样就可以根据设计稿进行快速适配，例如设计稿的宽度是 750px，那么 1px 就是 1rpx。



## 小程序冷启动和热启动

- **冷启动**：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。
- **热启动**：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。



## 小程序更新机制

### 1. 启动时同步更新

- 微信会定期检查小程序是否有版本更新，如果有更新，下次小程序启动时会同步更新代码包，更新到新版本后再打开小程序。
- 当用户长时间未使用小程序，启动时也会强制更新。
- 同步更新会阻塞小程序的启动流程，影响小程序的启动耗时。



### 2. 启动时异步更新

即使启动前未发现更新，小程序每次**冷启动**时，都会异步检查是否有更新版本。如果发现有新版本，将会异步下载新版本的代码包，供下次**冷启动**使用。



## 分包加载

分包加载指的是将小程序划分成不同的子包，在构建时打包成不同的分包，用户使用时按需进行加载。使用分包的小程序必定包含一个**主包**。主包指的是放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本；而**分包**则是根据开发者的配置进行划（通过 `app.json` 文件的 `subpackages` 字段进行配置）。

在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。

目前小程序分包大小有以下限制：

- 整个小程序所有分包大小不超过 20M
- 单个分包/主包大小不能超过 2M

对小程序进行分包，可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。



## 小程序登录

![login](./assets/login.jpg)



## 小程序优化

- sitemap 配置（SEO）
- 基础库和低版本兼容
- 初始渲染缓存
- 分包加载
- 减少不必要的全局组件和插件
- 减少本地资源原件，使用网络资源和利用 CDN 加速
- 使用开发者工具的静态代码分析，剔除不需要的代码
- 按需注入和用时注入
- 周期性更新
- 数据预拉取
- 合理使用 `setData()`：只传渲染相关数据、只传发生变化的数据、减少使用频率（合并）、