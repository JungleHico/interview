# 计算机网络常见面试题

## 目录

- [HTML](../html/html.md)

- [CSS](../css/css.md)

- [JavaScript](../js/js.md)

- [笔试题](../code/code.md)

- [TypeScript](../typescript/typescript.md)

- [Vue](../vue/vue.md)

- [Webpack 和前端工程化](../webpack/webpack.md)

- [微信小程序](../mini-program/mini-program.md)

- [计算机网络](../network/network.md)

## 计算机网络的五层体系结构

- **应用层**：是通过应用进程间的交互来完成特定网络应用。常见的应用层协议有 HTTP、DNS、SMTP。
- **传输层**：负责向两台主机进程之间的通信提供通用的数据传输服务。传输层主要包含 TCP 和 UDP 两种协议，TCP 是提供**面向连接的**、**可靠的**服务；UDP 提供**无连接**的，尽最大努力的数据传输服务。
- **网络层**：负责为分组交换网上的不同主机提供通信。在 TCP/UDP 协议中，网络层使用 IP 协议，发送 IP 报文。
- **数据链路层**：将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。
- **物理层**：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。

## 在地址栏里输入一个地址回车会发生哪些事情？

1. 解析 URL：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。
2. 缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。
3. DNS 解析： 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。
4. 获取 MAC 地址： 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。
5. TCP 三次握手： 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向客户端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。
6. HTTPS 握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。
7. 返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。
8. 页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。
9. TCP 四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。

## GET 请求和 POST 请求

|          | GET 请求                                    | POST 请求                                        |
| -------- | ------------------------------------------- | ------------------------------------------------ |
| 发送方式 | 通过 URL 发送，参数通过 & 连接              | 发送请求体                                       |
| 数据类型 | 只支持 ASCII 字符                           | 二进制数据                                       |
| 语义     | 用于请求数据                                | 用于提交数据                                     |
| 缓存     | 能被浏览器缓存，再次访问返回 304            | 不能被浏览器缓存                                 |
| 数据长度 | 浏览器对 URL 长度有限制，一般是 2048 个字符 | 无限制                                           |
| 数据包   | 一次发送                                    | 浏览器一般分两次发送，先发送请求头，再发送请求体 |
| 安全     | 敏感数据放在 URL 请求参数中会暴露           |                                                  |

## http1.0，http1.1 和 http2.0 协议

- http1.0：每次请求和响应完毕后都会销毁 TCP 连接，而且前一个响应完成后才能发送下一个请求，这就意味着连接无法复用，每次请求都需要重新建立连接，而且如果前一个请求阻塞，会影响后面的请求。
- http1.1：支持长连接，请求头设置 `connection:keep-alive`，一段时间内可以复用之前的 TCP 连接；支持管道化，下一个请求不需要等待上一个请求响应完成才开始发送，不过响应顺序必须和发送顺序保持一致，因此也不支持多路复用；支持断点续传。
- http2.0：采用二进制分帧，每帧都有符号标识，标识该帧属于哪个流，且一个 TCP 连接可以存在多条流，也就是可以发送多个请求（多路复用），这样不再有请求阻塞的问题和响应顺序的限制；头部压缩，头部数据量减少，传输速率提高。

## 浏览器缓存

浏览器缓存策略分为**强缓存**和**协商缓存**两种。

### 强缓存

强缓存不会向服务器发请求，而是从缓存中读取资源，强缓存可以通过 response header 的 `expires` 和 `cache-control` 进行控制。

`expires` 表示缓存的过期时间，有个缺点是受本地时间影响，修改本地时间会影响缓存。

`cache-control` 的优先级比 `expires` 高，有多个取值，最常见的是 `max-age`，表示缓存的有效时间，比如 `cache-control: max-age=600` 表示 600 秒后过期。

### 协商缓存

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。协商缓存可以通过 response header 的 `last-Modifined` 和 `etag` 进行控制。

`last-modifined` 表示文件最后修改时间，当浏览器第二次请求资源时，请求头会添加这个过期时间，服务器会将这个时间和文件最后修改时间比较，如果没有变化，说明资源没有变化，于是返回 304 状态码；如果资源有变化，则返回新的资源，状态码为 200。

`etag` 与 `last-modefined` 类似，只不过是一个 `token`，发送请求时比较本地 `token` 与服务器 `token` 是否一致。`etag` 的优先级比 `last-Modefined` 高。

## cookie 和 Storage

|           | cookie                           | Storage                                                        |
| --------- | -------------------------------- | -------------------------------------------------------------- |
| http 请求 | 发送请求时请求头会包含 cookie    | Storage 只存储在客户端                                         |
| 大小      | 一般 4KB                         | 一般 5MB                                                       |
| 有效期    | 可以设置过期时间，默认浏览器关闭 | `localStorage` 长期保存，`sessionStorage` 持续到网页会话被关闭 |

## JWT

JWT（JSON web Token）是一种基于 token 的身份验证和数据交换技术，一般包含三个部分：header、payload 和 signature。

- header：一般包含签名算法和令牌类型
- payload：标识主体信息（明文），一般包含令牌过期时间、发布时间、发行者、主体信息等
- signature：基于特定算法对前两部分加密后的结果，服务端接收后校验加密结果

## 单点登录

单点登录（Single Sign On）指的是在同一账号平台的多个应用系统中，用户只需要登录一次，即可访问所有相互信任的应用系统，例如登录了百度贴吧的网站，打开其他百度系的网站，例如百度网盘，百度地图等，就会保持登录状态。单点登录常见的实现方式有两种，一种是共享 Cookie，另一种是部署认证中心。

- 共享 Cookie：将 Cookie 的域名设置为主域名，这样所有的子域名的站点中就可以共享 Cookie，从而实现共享登录状态，这种方式的弊端是只能在主域名相同的站点中实现单点登录。
- 部署认证中心：部署一个专门用于处理登录请求的 web 服务，称为认证中心，用户统一在认证中心进行登录，用户登录后，认证中心会创建全局会话，保存用户登录状态，同时系统应用会创建局部会话，并生成 token 回传给客户端。

## 如何解决跨域问题

1. JSONP

JSONP（JSON with padding）是通过动态创建`<script>` 元素并为 `src` 属性指定跨域 URL 实现的。JSONP 可以从不同域拉去可执行代码，但不能防止域的恶意代码，而且不能确定 JSONP 请求是否失败。

2. CORS

CORS（Cross-Origin Resource Sharing）跨域资源请求，通过使用自定义 HTTP 头部来实现浏览器与服务器的跨域通讯，服务器端通过 `Access-Control-Allow-Origin` 匹配浏览器请求。

3. proxy

受浏览器同源策略的影响，浏览器不能跨域访问接口，而服务器不受此策略的影响，所以可以通过本地服务器代理请求，然后访问不同源的接口。

## 常见 Web 漏洞

### 1. SQL 注入

Web 应用程序对用户的输入没有做严格的判断，导致用户可用将非法的 SQL 语句拼接到正常的语句中，被当作 SQL 语句的一部分执行。

### 2. XSS

跨站脚本攻击（Cross-Site Scripting），恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。一般框架都会对 XSS 进行过滤，例如 Vue 的 `v-html` 指令。

### 3. CSRF

CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的 Web 攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。可以通过设置 Cookie 的 SameSite 设置 Cookie 不能跨域访问，也可以通过 Token 来避免 CSRF 攻击。

### 4. 暴力破解

攻击者通过穷举的方式对用户密码进行爆破。一般通过验证码、非人机验证、密码多次输入错误后延长输入时间、异地登录提示等方式进行防范。

### 5. 文件上传

攻击者可以上传一个与网站脚本语言相对应的**恶意代码动态脚本**到服务器上，然后访问这些恶意脚本中包含的恶意代码,从而获得了**执行服务器端命令**的能力,进一步影响服务器安全。前端对文件上传的类型进行过滤。
